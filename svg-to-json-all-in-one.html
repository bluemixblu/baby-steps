<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG to hanzi-writer JSON V3.9</title>
    <style>
        body { font-family: "Microsoft JhengHei", Arial, sans-serif; max-width: 1400px; margin: 0 auto; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; }
        .container { background: white; padding: 30px; border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); }
        h1 { color: #667eea; border-bottom: 4px solid #667eea; padding-bottom: 15px; text-align: center; font-size: 28px; }
        .subtitle { text-align: center; color: #666; margin-bottom: 30px; font-size: 14px; }
        .info-box { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; padding: 20px; margin: 20px 0; border-radius: 10px; }
        .upload-area { border: 3px dashed #667eea; border-radius: 15px; padding: 60px; text-align: center; background: #f8f9ff; cursor: pointer; transition: all 0.3s ease; position: relative; }
        .upload-area:hover { background: #e8ebff; border-color: #764ba2; transform: translateY(-2px); }
        .upload-area input[type="file"] { position: absolute; width: 100%; height: 100%; top: 0; left: 0; opacity: 0; cursor: pointer; }
        .file-list { margin: 20px 0; }
        .file-item { background: #f8f9ff; padding: 12px 15px; margin: 8px 0; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; border-left: 4px solid #667eea; }
        .preview-area { margin: 20px 0; }
        textarea { width: 100%; min-height: 150px; padding: 15px; border: 2px solid #ddd; border-radius: 8px; font-family: "Consolas", monospace; font-size: 14px; resize: vertical; box-sizing: border-box; }
        textarea#output { min-height: 300px; background: #f8f9ff; }
        input[type="text"] { width: 100%; padding: 12px 15px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px; box-sizing: border-box; }
        button { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 15px 40px; font-size: 18px; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; font-weight: bold; }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4); }
        button.secondary { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .btn-container { display: flex; gap: 15px; justify-content: center; margin: 30px 0; flex-wrap: wrap; }
        .section-title { font-size: 20px; font-weight: bold; color: #667eea; margin: 30px 0 15px 0; padding-left: 15px; border-left: 5px solid #764ba2; }
        .label { display: block; font-weight: bold; color: #333; margin-bottom: 8px; font-size: 16px; }
        .success { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; padding: 20px; border-radius: 10px; margin: 20px 0; text-align: center; }
    </style>
</head>
<body>
    <div class="container">
        <h1>SVG to hanzi-writer JSON V3.9</h1>
        <div class="subtitle">V3.9 Fix: Curved strokes (hooks) now included in median</div>
        
        <div class="info-box">
            <strong>V3.9 Key Fix:</strong>
            <div style="margin-top: 10px; line-height: 1.8;">
                For curved strokes (like vertical-bend-hook): use maxX method<br>
                Takes path from start to rightmost point (includes the hook!)<br>
                <strong style="color: #ffd700;">Press F12 to view diagnostic logs!</strong>
            </div>
        </div>
        
        <div class="section-title">Step 1: Upload SVG Files</div>
        <div class="upload-area" id="uploadArea">
            <input type="file" id="fileInput" accept=".svg" multiple>
            <div style="font-size: 60px;">?</div>
            <div style="font-size: 20px; margin: 15px 0; font-weight: bold;">Drag or click to upload SVG files</div>
        </div>
        
        <div id="fileList" class="file-list"></div>
        <div id="previewArea" class="preview-area"></div>
        
        <div class="section-title">Step 2: RadStrokes (Optional)</div>
        <div style="margin: 20px 0;">
            <label class="label">RadStrokes (radical stroke indices):</label>
            <input type="text" id="radStrokesInput" placeholder="Example: 0,1,2,3">
        </div>
        
        <div class="btn-container">
            <button onclick="generateJSON()">Generate JSON</button>
            <button onclick="clearAll()" class="secondary">Clear All</button>
        </div>
        
        <div id="successMsg" style="display: none;"></div>
        
        <div class="section-title">Step 3: Preview & Test</div>
        <div style="display: flex; gap: 30px; flex-wrap: wrap; justify-content: center; margin: 20px 0;">
            <div style="text-align: center;">
                <div style="font-weight: bold; margin-bottom: 10px;">Character Display</div>
                <div id="charDisplay" style="width: 200px; height: 200px; border: 2px solid #667eea; border-radius: 10px; background: #fffef0;"></div>
            </div>
            <div style="text-align: center;">
                <div style="font-weight: bold; margin-bottom: 10px;">Animation</div>
                <div id="charAnimation" style="width: 200px; height: 200px; border: 2px solid #667eea; border-radius: 10px; background: #fffef0;"></div>
                <button onclick="playAnimation()" style="margin-top: 10px; padding: 8px 20px; font-size: 14px;">Play Animation</button>
            </div>
            <div style="text-align: center;">
                <div style="font-weight: bold; margin-bottom: 10px;">Writing Practice</div>
                <div id="charQuiz" style="width: 200px; height: 200px; border: 2px solid #667eea; border-radius: 10px; background: #fffef0;"></div>
                <button onclick="startQuiz()" style="margin-top: 10px; padding: 8px 20px; font-size: 14px;">Start Practice</button>
            </div>
        </div>
        
        <div class="section-title">Step 4: Copy JSON</div>
        <textarea id="output" placeholder="Generated JSON will appear here..." readonly></textarea>
        
        <div class="btn-container">
            <button onclick="copyToClipboard()">Copy to Clipboard</button>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/hanzi-writer@3.5/dist/hanzi-writer.min.js"></script>

    <script>
        let svgFiles = [], extractedPaths = [];
        const uploadArea = document.getElementById('uploadArea'), fileInput = document.getElementById('fileInput');
        
        uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.style.background = '#e8ebff'; });
        uploadArea.addEventListener('dragleave', () => { uploadArea.style.background = '#f8f9ff'; });
        uploadArea.addEventListener('drop', (e) => { e.preventDefault(); uploadArea.style.background = '#f8f9ff'; handleFiles(Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.svg'))); });
        fileInput.addEventListener('change', (e) => { handleFiles(Array.from(e.target.files)); });
        
        function handleFiles(files) {
            svgFiles = files.sort((a, b) => a.name.localeCompare(b.name));
            displayFileList();
            extractAllPaths();
        }
        
        function displayFileList() {
            const listDiv = document.getElementById('fileList');
            listDiv.innerHTML = '<div style="font-weight: bold; margin-bottom: 10px;">Loaded ' + svgFiles.length + ' files</div>';
            svgFiles.forEach((file, index) => {
                const item = document.createElement('div');
                item.className = 'file-item';
                item.innerHTML = '<span>' + (index + 1) + '. ' + file.name + '</span><span>OK</span>';
                listDiv.appendChild(item);
            });
        }
        
        function extractAllPaths() {
            extractedPaths = [];
            const promises = svgFiles.map(file => new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result, pathMatch = content.match(/<path[^>]*d="([^"]*)"/);
                    if (pathMatch && pathMatch[1]) {
                        let path = pathMatch[1];
                        path = path.replace(/(\d+)\.\d+/g, (match) => Math.round(parseFloat(match)).toString());
                        path = path.replace(/\s*Z\s*$/gi, '').replace(/\s+Z\s+/gi, ' ');
                        resolve(path.trim());
                    } else { resolve(null); }
                };
                reader.readAsText(file);
            }));
            
            Promise.all(promises).then(paths => {
                const allPaths = paths.filter(p => p !== null);
                extractedPaths = extractIndividualStrokes(allPaths);
                displayPreview();
            });
        }
        
        function extractIndividualStrokes(allPaths) {
            if (allPaths.length === 0) return [];
            if (allPaths.length === 1) return allPaths;
            const path1Sample = allPaths[0].substring(0, Math.min(150, allPaths[0].length));
            const isCumulative = allPaths.length >= 2 && allPaths[1].includes(path1Sample.substring(0, 80));
            if (!isCumulative) return allPaths;
            const strokes = [];
            for (let i = 0; i < allPaths.length; i++) {
                const currentPath = allPaths[i], mPositions = [], regex = / M /g;
                let match;
                while ((match = regex.exec(currentPath)) !== null) mPositions.push(match.index);
                let newStroke = mPositions.length === 0 ? currentPath : currentPath.substring(mPositions[mPositions.length - 1] + 1);
                if (!newStroke.trim().startsWith('M')) newStroke = 'M ' + newStroke.trim();
                strokes.push(newStroke.trim());
            }
            return strokes;
        }
        
        function displayPreview() {
            const previewDiv = document.getElementById('previewArea');
            previewDiv.innerHTML = '<div class="section-title">Extracted ' + extractedPaths.length + ' strokes</div>';
        }
        
        // Coordinate transformation: 540 system to 900 system
        // 540: top-left (0,0), bottom-right (540,540), Y increases downward
        // 900: top-left (0,900), bottom-right (900,0), Y increases upward
        function transformCoordinate(x, y) {
            const scale = 900 / 540;
            const newX = x * scale;
            const newY = 900 - (y * scale);  // Y-axis flip!
            return [Math.round(newX), Math.round(newY)];
        }
        
        function transformPath(path) {
            return path.replace(/(-?\d+)\s+(-?\d+)/g, function(match, x, y) {
                const [newX, newY] = transformCoordinate(parseInt(x), parseInt(y));
                return newX + ' ' + newY;
            });
        }
        
        function extractMedianFromPath(path, strokeIndex) {
            console.log('\n========== Stroke ' + (strokeIndex + 1) + ' median generation ==========');
            const points = [], commands = path.match(/[MLQCZ][^MLQCZ]*/g);
            if (!commands || commands.length === 0) return [[0, 0], [100, 100]];
            
            commands.forEach(cmd => {
                const type = cmd[0], coordsStr = cmd.slice(1).trim(), coords = coordsStr.match(/-?\d+/g);
                if (!coords || coords.length < 2) return;
                if (type === 'M' || type === 'L') points.push([parseInt(coords[0]), parseInt(coords[1])]);
                else if (type === 'Q' && coords.length >= 4) points.push([parseInt(coords[coords.length - 2]), parseInt(coords[coords.length - 1])]);
                else if (type === 'C' && coords.length >= 6) points.push([parseInt(coords[coords.length - 2]), parseInt(coords[coords.length - 1])]);
            });
            
            console.log('Extracted', points.length, 'points');
            if (points.length === 0) return [[0, 0], [100, 100]];
            if (points.length === 1) return [points[0], points[0]];
            if (points.length === 2) return points;
            
            let simplified;
            if (isClosedPath(points)) {
                console.log('CLOSED PATH detected');
                simplified = simplifyClosedPath(points);
            } else {
                console.log('Open path');
                simplified = simplifyOpenPath(points);
            }
            
            console.log('After simplify:', simplified.length, 'points');
            console.log('Y values (540 system):', simplified.map(p => p[1]).join(' -> '));
            
            simplified = samplePoints(simplified, 15);
            console.log('After sampling:', simplified.length, 'points');
            
            const beforeCorrection = simplified.map(p => [...p]);
            simplified = correctMedianDirection(simplified);
            const wasReversed = beforeCorrection[0][0] !== simplified[0][0] || beforeCorrection[0][1] !== simplified[0][1];
            console.log('Direction correction:', wasReversed ? 'REVERSED' : 'unchanged');
            console.log('Final Y values (540 system):', simplified.map(p => p[1]).join(' -> '));
            console.log('==========================================\n');
            
            return simplified;
        }
        
        function isClosedPath(points) {
            if (points.length < 3) return false;
            const start = points[0], end = points[points.length - 1];
            const distance = Math.sqrt(Math.pow(end[0] - start[0], 2) + Math.pow(end[1] - start[1], 2));
            return distance < 10;
        }
        
        // V3.9 FIX: Better handling of complex closed paths (e.g., hooks)
        // For strokes with curves/hooks, use maxX method instead of minY/maxY
        function simplifyClosedPath(points) {
            console.log('  [Closed Path] Original points:', points.length);
            
            // Find min/max indices for both X and Y
            let maxYIndex = 0, minYIndex = 0, maxXIndex = 0, minXIndex = 0;
            for (let i = 1; i < points.length; i++) {
                if (points[i][1] > points[maxYIndex][1]) maxYIndex = i;
                if (points[i][1] < points[minYIndex][1]) minYIndex = i;
                if (points[i][0] > points[maxXIndex][0]) maxXIndex = i;
                if (points[i][0] < points[minXIndex][0]) minXIndex = i;
            }
            
            console.log('  minY (top):', 'index=' + minYIndex, 'coord=(' + points[minYIndex][0] + ',' + points[minYIndex][1] + ')');
            console.log('  maxY (bottom):', 'index=' + maxYIndex, 'coord=(' + points[maxYIndex][0] + ',' + points[maxYIndex][1] + ')');
            console.log('  maxX (right):', 'index=' + maxXIndex, 'coord=(' + points[maxXIndex][0] + ',' + points[maxXIndex][1] + ')');
            
            const deltaX = Math.abs(points[maxYIndex][0] - points[minYIndex][0]);
            const deltaY = Math.abs(points[maxYIndex][1] - points[minYIndex][1]);
            console.log('  deltaX:', deltaX, 'deltaY:', deltaY, 'ratio:', (deltaX/deltaY).toFixed(2));
            
            let result;
            
            // Check if it's a left-falling stroke (ºJ): top point is significantly to the right of bottom point
            // Use threshold of 30 pixels to avoid false positives on vertical strokes
            const xDiff = points[minYIndex][0] - points[maxYIndex][0];
            const isLeftFalling = xDiff > 30;
            console.log('  minY.x:', points[minYIndex][0], 'maxY.x:', points[maxYIndex][0], 'xDiff:', xDiff);
            console.log('  isLeftFalling (ºJ):', isLeftFalling, '(threshold: 30)');
            
            if (isLeftFalling) {
                // ===== ºJ (LEFT-FALLING STROKE) =====
                // Writing direction: from top-right (maxX) to bottom-left (minX)
                console.log('  -> ºJ (Left-falling): maxX to minX');
                console.log('  maxXIndex:', maxXIndex, 'minXIndex:', minXIndex);
                
                if (maxXIndex < minXIndex) {
                    // maxX comes first, minX comes later - direct slice
                    console.log('  -> Direct: [' + maxXIndex + ', ' + (minXIndex + 1) + ')');
                    result = points.slice(maxXIndex, minXIndex + 1);
                } else {
                    // Need to wrap around the closed path
                    console.log('  -> Wrap: [' + maxXIndex + ' to end] + [1 to ' + (minXIndex + 1) + ')');
                    const part1 = points.slice(maxXIndex);
                    const part2 = points.slice(1, minXIndex + 1);
                    result = part1.concat(part2);
                }
            } else if (deltaY > deltaX * 2.5) {
                // ===== PURE VERTICAL STROKE =====
                console.log('  -> Pure Vertical (deltaY > deltaX*2.5)');
                if (minYIndex < maxYIndex) {
                    result = points.slice(minYIndex, maxYIndex + 1);
                } else {
                    result = points.slice(maxYIndex, minYIndex + 1).reverse();
                }
            } else if (deltaX > deltaY * 2.5) {
                // ===== PURE HORIZONTAL STROKE =====
                console.log('  -> Pure Horizontal (deltaX > deltaY*2.5)');
                if (minXIndex < maxXIndex) {
                    result = points.slice(minXIndex, maxXIndex + 1);
                } else {
                    result = points.slice(maxXIndex, minXIndex + 1).reverse();
                }
            } else if (deltaX >= deltaY) {
                // ===== CURVED HORIZONTAL (like ¾î) =====
                console.log('  -> Curved Horizontal: minX to maxX');
                console.log('  minXIndex:', minXIndex, 'maxXIndex:', maxXIndex);
                if (minXIndex < maxXIndex) {
                    result = points.slice(minXIndex, maxXIndex + 1);
                } else {
                    const part1 = points.slice(minXIndex);
                    const part2 = points.slice(1, maxXIndex + 1);
                    result = part1.concat(part2);
                }
            } else {
                // ===== CURVED VERTICAL (like ½ÝÅs¹_) =====
                console.log('  -> Curved Vertical: start to maxX');
                result = points.slice(0, maxXIndex + 1);
                
                // If Y is decreasing, we took the wrong half - use alternative
                if (result.length >= 2 && result[0][1] > result[result.length - 1][1]) {
                    console.log('  -> Y decreasing, using wrap method');
                    const part1 = points.slice(maxXIndex);
                    const part2 = points.slice(1, 1); // Just to close the loop if needed
                    result = part1;
                }
            }
            
            console.log('  Result:', result.length, 'points');
            console.log('  Y values:', result.map(p => p[1]).join(' -> '));
            return result;
        }
        
        function simplifyOpenPath(points) {
            if (points.length <= 3) return points;
            const startPoint = points[0], endPoint = points[points.length - 1];
            const deltaX = Math.abs(endPoint[0] - startPoint[0]), deltaY = Math.abs(endPoint[1] - startPoint[1]);
            let mainDirection = deltaX > deltaY * 1.5 ? 'horizontal' : deltaY > deltaX * 1.5 ? 'vertical' : 'diagonal';
            const filtered = [points[0]];
            if (mainDirection === 'vertical') {
                const goingDown = endPoint[1] > startPoint[1];
                for (let i = 1; i < points.length - 1; i++) {
                    const prevPoint = filtered[filtered.length - 1], currPoint = points[i];
                    if ((goingDown && currPoint[1] >= prevPoint[1]) || (!goingDown && currPoint[1] <= prevPoint[1])) filtered.push(currPoint);
                }
            } else if (mainDirection === 'horizontal') {
                const goingRight = endPoint[0] > startPoint[0];
                for (let i = 1; i < points.length - 1; i++) {
                    const prevPoint = filtered[filtered.length - 1], currPoint = points[i];
                    if ((goingRight && currPoint[0] >= prevPoint[0]) || (!goingRight && currPoint[0] <= prevPoint[0])) filtered.push(currPoint);
                }
            } else {
                for (let i = 1; i < points.length - 1; i++) {
                    const prevPoint = filtered[filtered.length - 1], currPoint = points[i];
                    const progressPrev = (prevPoint[0] - startPoint[0]) * (endPoint[0] - startPoint[0]) + (prevPoint[1] - startPoint[1]) * (endPoint[1] - startPoint[1]);
                    const progressCurr = (currPoint[0] - startPoint[0]) * (endPoint[0] - startPoint[0]) + (currPoint[1] - startPoint[1]) * (endPoint[1] - startPoint[1]);
                    if (progressCurr >= progressPrev * 0.95) filtered.push(currPoint);
                }
            }
            filtered.push(points[points.length - 1]);
            return filtered.length >= 2 ? filtered : points;
        }
        
        function samplePoints(points, targetCount) {
            if (points.length <= targetCount) return points;
            const sampled = [points[0]], step = (points.length - 1) / (targetCount - 1);
            for (let i = 1; i < targetCount - 1; i++) {
                const index = Math.round(i * step);
                if (index > 0 && index < points.length - 1) sampled.push(points[index]);
            }
            sampled.push(points[points.length - 1]);
            return sampled;
        }
        
        // Direction correction for 540 system
        // Vertical: Y should increase (top to bottom)
        // Horizontal: X should increase (left to right)
        function correctMedianDirection(median) {
            if (median.length < 2) return median;
            const startPoint = median[0], endPoint = median[median.length - 1];
            const deltaX = Math.abs(endPoint[0] - startPoint[0]), deltaY = Math.abs(endPoint[1] - startPoint[1]);
            let shouldReverse = false;
            
            if (deltaX > deltaY * 1.5) {
                // Horizontal: X should increase
                if (startPoint[0] > endPoint[0]) shouldReverse = true;
            } else if (deltaY > deltaX * 1.5) {
                // Vertical: Y should increase in 540 system (top to bottom)
                if (startPoint[1] > endPoint[1]) shouldReverse = true;
            } else {
                // Diagonal: usually top-left to bottom-right, so Y should increase
                if (startPoint[1] > endPoint[1]) shouldReverse = true;
            }
            
            return shouldReverse ? median.slice().reverse() : median;
        }
        
        function generateJSON() {
            if (extractedPaths.length === 0) { alert('Please upload SVG files first!'); return; }
            
            console.clear();
            console.log('========== V3.9 JSON Generation ==========');
            console.log('Total strokes:', extractedPaths.length);
            
            const transformedStrokes = extractedPaths.map(path => transformPath(path));
            const json = {
                strokes: transformedStrokes,
                medians: extractedPaths.map((path, index) => {
                    const originalMedian = extractMedianFromPath(path, index);
                    const transformed = originalMedian.map(point => transformCoordinate(point[0], point[1]));
                    console.log('Stroke ' + (index + 1) + ' final median (900 system):', transformed.map(p => '(' + p[0] + ',' + p[1] + ')').join(' -> '));
                    return transformed;
                })
            };
            
            const radStrokesText = document.getElementById('radStrokesInput').value.trim();
            if (radStrokesText) json.radStrokes = radStrokesText.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
            
            console.log('\n========== Generation Complete ==========');
            console.log('Check Stroke 1 Y values - should DECREASE (e.g., 800 -> 700 -> 600)');
            
            const output = JSON.stringify(json, null, 2);
            document.getElementById('output').value = output;
            
            const successMsg = document.getElementById('successMsg');
            successMsg.className = 'success';
            successMsg.innerHTML = '<div style="font-size: 20px; margin-bottom: 10px;">V3.9 JSON Generated!</div><div>Strokes: ' + extractedPaths.length + '</div><div style="color:#ffd700; margin-top:10px;"><strong>Preview ready! Check F12 for diagnostics.</strong></div>';
            successMsg.style.display = 'block';
            
            // Create preview
            try {
                createPreview(json);
                console.log('Preview created successfully!');
            } catch (e) {
                console.error('Preview error:', e);
            }
        }
        
        function copyToClipboard() {
            const output = document.getElementById('output');
            if (!output.value) { alert('No JSON generated yet!'); return; }
            output.select(); document.execCommand('copy'); alert('Copied!');
        }
        
        function clearAll() {
            if (confirm('Clear all?')) {
                svgFiles = []; extractedPaths = [];
                document.getElementById('fileList').innerHTML = '';
                document.getElementById('previewArea').innerHTML = '';
                document.getElementById('radStrokesInput').value = '';
                document.getElementById('output').value = '';
                document.getElementById('successMsg').style.display = 'none';
                document.getElementById('charDisplay').innerHTML = '';
                document.getElementById('charAnimation').innerHTML = '';
                document.getElementById('charQuiz').innerHTML = '';
                fileInput.value = '';
                currentCharData = null;
                writerDisplay = null;
                writerAnimation = null;
                writerQuiz = null;
            }
        }
        
        // Preview functionality
        let currentCharData = null;
        let writerDisplay = null;
        let writerAnimation = null;
        let writerQuiz = null;
        
        function createPreview(jsonData) {
            currentCharData = jsonData;
            
            // Clear previous writers
            document.getElementById('charDisplay').innerHTML = '';
            document.getElementById('charAnimation').innerHTML = '';
            document.getElementById('charQuiz').innerHTML = '';
            
            // Create display writer
            writerDisplay = HanziWriter.create('charDisplay', null, {
                width: 200,
                height: 200,
                padding: 10,
                strokeColor: '#333',
                radicalColor: '#c87e74',
                charDataLoader: function(char, onComplete) {
                    onComplete(currentCharData);
                }
            });
            writerDisplay.setCharacter('test');
            
            // Create animation writer
            writerAnimation = HanziWriter.create('charAnimation', null, {
                width: 200,
                height: 200,
                padding: 10,
                strokeColor: '#333',
                radicalColor: '#c87e74',
                delayBetweenStrokes: 300,
                charDataLoader: function(char, onComplete) {
                    onComplete(currentCharData);
                }
            });
            writerAnimation.setCharacter('test');
            
            // Create quiz writer
            writerQuiz = HanziWriter.create('charQuiz', null, {
                width: 200,
                height: 200,
                padding: 10,
                showCharacter: false,
                showOutline: true,
                strokeColor: '#333',
                radicalColor: '#c87e74',
                highlightColor: '#38ef7d',
                drawingColor: '#667eea',
                charDataLoader: function(char, onComplete) {
                    onComplete(currentCharData);
                }
            });
            writerQuiz.setCharacter('test');
        }
        
        function playAnimation() {
            if (writerAnimation) {
                writerAnimation.animateCharacter();
            } else {
                alert('Please generate JSON first!');
            }
        }
        
        function startQuiz() {
            if (writerQuiz) {
                writerQuiz.quiz({
                    onComplete: function(summaryData) {
                        console.log('Quiz complete!', summaryData);
                    }
                });
            } else {
                alert('Please generate JSON first!');
            }
        }
    </script>
</body>
</html>

</html>
